#!/usr/bin/python

import os
import stat
import json
import sys
import urllib
import pysvn
import subprocess
import shutil
import pwd
import grp
import hashlib
import ConfigParser
from optparse import OptionParser, OptionGroup
import fcntl
import logging
import logging.handlers
import errno
import smtplib
from email.mime.text import MIMEText

## TODO
# e-mail fault response							1		(easy)
# bootstrap command?							5		(easy)
	# create /opt/scs/ etc.
	# create /etc/scs.conf with server as https://scs.domain/ and all other defaults
# description truncate?							2		(EASY)
# new actions "pkg-info" and "chan-info" ??		3
	# pkg-info will just print fields
	# channel info will print channel members
	
# move def's to scslib??						4

def saveMetadata():
	global metadataDict
	global metadataFile
	
	if not metadataDict == None:
		#### save metadata changes to disk
		## Turn "metadict" into json
		jsonOut = json.dumps(metadataDict, sort_keys=True, indent=4)

		## Write to file
		try:
			metadataFile.seek(0)
			metadataFile.truncate(0)
			metadataFile.write(jsonOut)
			metadataFile.close
		except (IOError, OSError) as e:
			sys.stderr.write('Failed to write client metadata: ' + e.strerror + ' on ' + e.filename)
			sys.exit(255)

################################################################################
################################################################################

def openLog(logfile):
	global logOpened
	global logger

	logger = logging.getLogger('scs')
	logger.setLevel(logging.DEBUG)
	handler = logging.handlers.RotatingFileHandler(logfile, maxBytes=512000, backupCount=5)
	formatter = logging.Formatter("%(asctime)s %(name)s %(levelname)s: %(message)s")
	handler.setFormatter(formatter)
	logger.addHandler(handler)
	logOpened = True

def debug(o,log=False):
	global options
	global logOpened
	global logger
	
	if not options.quiet:
		if options.debug:
			print str(o)
			
	if log and logOpened:
		logger.debug(str(o))

def warn(o,log=True):
	global options
	global logOpened
	global logger	
	
	if not options.quiet:
		print str(o)
		
	if log and logOpened:
		logger.warning(str(o))

def error(o,log=True):
	global logOpened
	global logger
	sys.stderr.write(str(o) + "\n")
	
	if log and logOpened:
		logger.error(str(o))
	
def info(o,log=False):
	global options
	global logOpened
	global logger
	
	if not options.quiet:
		print str(o)
		
	if log and logOpened:
		logger.info(str(o))

def fatal(o,exitcode=1,log=True):
	global logOpened
	global logger
	
	## First save any metadata changes
	saveMetadata()
	
	## Log the fault
	if log and logOpened:
		logger.critical(str(o))	
	
	## Panic and quit
	sys.stderr.write('FATAL: ' + str(o) + "\n")
	sys.exit(exitcode)

################################################################################
################################################################################

## "check" property
### before increment it checks all files with "check" property
#### check value can be:
#### - fail - Fail the entire package upgrade if the local file has changed - DOES NOT OVERWRITE
#### - ignore - (default) - Do nothing - don't care - OVERWITES LOCAL CHANGES
#### - warn - Warn the file has changed - OVERWRITES LOCAL CHANGES
#### - skip - don't change /that/ file, and that file alone, on the next increment - DOES NOT OVERWRITE
def checkForLocalChanges(pkg):
	global conf
	ignoreList = []
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)
	
	## Return code
	# 0 - no locally changed files
	# 1 - locally changed files, but they were all skipped
	# 2 - locally changed files, but they were all skipped or warned about
	# 3 - locally changed files, DO NOT PROCEED!
	retcode = 0

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']
			debug('Checking for local changes on file: ' + dest,log=True)

			## Get SHA sums
			try:
				sourceh = shasum(source)
				desth   = shasum(dest)
			except Exception as e:
				warn('Cannot check for local changes on ' + dest + ': ' + str(e))
			else:
				## Compare sums
				if not sourceh == desth:

					info('The file ' + dest + ' has been modified outside of SCS control',log=True)

					## TODO FUTURE make the default come from a revprop? (difficult...)
					checkAction = 'ignore'

					if 'check' in properties:
						checkAction = properties['check']

					debug('The file has been configured to "' + checkAction + '" in this scenario',log=True)

					if checkAction == 'fail':
						retcode = 3
						output("ERROR! Local changes found to file " + dest)						
					elif checkAction == 'warn':
						retcode = 2					
						output("WARNING! Local changes found to file " + dest)
					elif checkAction == 'skip':
						retcode = 1					
						## add the file to the "ignore" list
						ignoreList.append(source)
						
	return (retcode, ignoreList)

################################################################################
################################################################################

def packageInstalled(pkg):
	global metadataDict

	if metadataDict['packages'].has_key(pkg):
		return True
	else:
		return False

################################################################################
################################################################################

def channelSubscribed(channel):
	global metadataDict

	if metadataDict['channels'].has_key(channel):
		return True
	else:
		return False

################################################################################
################################################################################

def listFiles(pkg):
	global conf
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']
			print '{0:38}  {1:38}'.format(dest, source)

def printPackageHeader():
	print '{0:14}  {1:14}  {2:37}  {3:9}'.format('PACKAGE NAME','LOCAL REVISION','DESCRIPTION','STATUS')
	print '{0:14}  {1:14}  {2:37}  {3:9}'.format('------------','--------------','-----------','------')

def printPackageInfo(pkg):
	data = metadataDict['packages'][pkg]
	if type(data).__name__=='dict':
		if isPackageSuspended(data['name']):
			flags = 'SUSPENDED'
		else:
			flags = 'OK'

		if data.has_key('name') and data.has_key('revision') and data.has_key('desc'):
			print "{0:14}  {1:14}  {2:37}  {3:9}".format(str(data['name']), str(data['revision']), str(data['desc']),flags)
		elif data.has_key('name') and data.has_key('revision'):
			print "{0:14}  {1:14}  {2:37}  {3:9}".format(str(data['name']), str(data['revision']), '', flags)
		else:
			fatal('Unable to understand data: ' + str(e))
	else:
		fatal('Unable to understand data: ' + str(e))

################################################################################
################################################################################

def suspendPackage(pkg,reason):
	global metadataDict

	if packageInstalled(pkg):
		metadataDict['packages'][pkg]['status'] = 'suspended'
		metadataDict['packages'][pkg]['suspend_reason'] = reason

def resumePackage(pkg):
	global metadataDict

	if isPackageSuspended(pkg):
		del(metadataDict['packages'][pkg]['status'])
		del(metadataDict['packages'][pkg]['suspend_reason'])

def isPackageSuspended(pkg):
	global metadataDict

	if packageInstalled(pkg):
		if metadataDict['packages'][pkg].has_key('status'):
			if metadataDict['packages'][pkg]['status'] == 'suspended':
				return True

	return False

################################################################################
################################################################################

def shasum(filePath,blocksize=2**20):
	sha = hashlib.sha256()
	f = open(filePath,'rb')
	while True:
		data = f.read(blocksize)
		if not data:
			break;
		sha.update(data)
	return sha.hexdigest()

################################################################################
################################################################################

def runScript(pkgName,scriptName):
	global conf
	debug('Executing ' + scriptName,log=True)
	scriptPath = os.path.join(conf['scsroot'],'packages',pkgName,'scripts',scriptName)

	## CHMOD First
	os.chmod(scriptPath,stat.S_IRWXU)

	if os.path.getsize(scriptPath) == 0:
		debug("Script is empty; not executing",log=True)
		return (0, '')

	## Now run the script
	try:
		script = subprocess.Popen([scriptPath],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		(stdoutdata, stderrdata) = script.communicate()
		return (script.returncode, stdoutdata)
	except OSError as e:
		## UNIX codes will only ever be 0-255
		## Thus use -1 to signify an OS error
		warn('Execution of script ' + scriptName + ' failed: ' + str(e))
		return (-1,str(e))

################################################################################
################################################################################

def fetchMetadata(metadataUrl):
	debug('Fetching metadata from server')
	try:
		f = urllib.urlopen(metadataUrl)
		jsonData = f.read()
		f.close()
	except IOError as e:
		fatal('Unable to read from ' + e.filename + ': ' + e.strerror)

	try:
		metadict = json.loads(jsonData)
	except (TypeError,ValueError) as e:
		fatal('Unable to understand server metadata: ' + str(e))

	return metadict

################################################################################
################################################################################

def uninitPkg(pkg):
	global conf

	if packageInstalled(pkg):
		(scode,sout) = runScript(pkg,'uninit')
		if not scode == 0:
			error(sout)
			error('Script "uninit" returned non-zero')
			return 1
		else:
			## Delete data
			shutil.rmtree(os.path.join(conf['scsroot'],'packages',pkg))

			## Update metadata
			del(metadataDict['packages'][pkg])

			## Output
			info('Removed package "' + pkg + '"')
	
			## Return OK
			return 0
	else:
		info('Package "' + pkg + '" not installed so not removing',log=True)
		return 0

################################################################################
################################################################################

# results
# 0 OK!
# 1 Could not upgrade
def updateChannel(channel):
	debug('updateChannel() called')
	global metadataDict
	global conf
	svnclient = pysvn.Client()

	if channelSubscribed(channel):	
		remotePath  = conf['svnroot'] + '/c_' + channel + '/'
		localPath   = os.path.join(conf['scsroot'],'channels',channel)
		localPkgs   = os.path.join(localPath,'packages')
		upgradeFile = remotePath + 'upgrade'

		## Get the latest revision of the channel
		infoList = svnclient.info2(remotePath,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			latestRevision = infoDict['rev']
		debug('Latest remote revision is ' + str(latestRevision.number))

		## Get the installed revision
		localRevision = int(metadataDict['channels'][channel]['revision'])
		debug('Latest local revision is ' + str(localRevision))

		## Decide upon which revision to go to????
		if localRevision == latestRevision.number:
			info('Channel "' + channel + '" is up to date')
			return
		else:
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, localRevision + 1)

		## No need to download the upgrade file, we'll just read its properties from remote :)
		## Get the properties
		propList = svnclient.proplist(upgradeFile,revision=revisionToUse)

		for propSet in propList:
			properties = propSet[1]

			if properties.has_key('name') and properties.has_key('revision') and properties.has_key('action'):
				if properties['action'] == 'install':
					## Install 'revision' of 'name'
					result = initPkg(properties['name'],int(properties['revision']))

					## Result of pkgInit
					if result > 0:

						errmsg = '';
											
				
						if result == 1:
							## A pre-script failed
							errmsg = "Could not upgrade channel. Please correct the error and try to upgrade again"
							
						elif result == 5:
							## Package is suspended
							errmsg = "Package is currently suspended. Please correct the error and try to upgrade again"
							
						elif  result == 6:
							## Package does not exist
							errmsg = "Package does not exist. Please correct the error and try to upgrade again"
							
						else:
							## A failure condition where the package should now be suspended
							
							if result == 2:
								## Property application failed - major fault
								suspendPackage(properties['name'],"A major fault occured when applying package properties")
								
							elif result == 3:
								## Property allocation failed - minor fault
								suspendPackage(properties['name'],"A minor fault occured when applying package properties")
								
							elif result == 4:
								## Post-script returned non-zero
								suspendPackage(properties['name'],"A post script returned an error after package installation")
								
							elif result == 7:
								## Changed files detected that fail the package upgrade
								suspendPackage(properties['name'],"One or more files have been changed locally")

							errmsg = "Package suspended. Channel could not be updated."
					

					## Alert email
					if not conf['mailaddr'] == None:
						msg = MIMEText(errmsg)
						msg['Subject'] = 'scs on HOSTNAME: Could not update channel `' + channel + '`'
						msg['From'] = 'from'
						msg['To'] = 'to'
					
						smtp = smtplib.SMTP(conf['smtp'])
						smtp.sendmail('root@null', conf['mailaddr'], msg.as_string())
						smtp.quit()
					
					## Print error
					error(errmsg)
					
					## Return 1 to say we failed
					return 1

			elif properties.has_key('name') and properties.has_key('action'):
				if properties['action'] == 'remove':
					## Remove 
					result = uninitPkg(properties['name'])

					if result == 1:
						fatal("Could not upgrade channel. Please correct the error and try to upgrade again")
						return 1
					
			else:
				warn('Warning! Channel upgrade file does not have properties set against it!')

		## Update package info (Although we don't actually use the info until an unsubscribe - but they are there if an admin wants them)
		svnclient.update(localPkgs,revision=revisionToUse)

		## Save new revision
		metadataDict['channels'][channel]['revision'] = revisionToUse.number;

		## We're upgraded
		if revisionToUse.number < latestRevision:
			## We need to recursive-call and upgrade again! :)
			updateChannel(channel)
		else:
			## We're done!
			return 0

	else:
		fatal('Not subscribed to channel ' + channel,log=False)

################################################################################
################################################################################

#### RETURN CODES for initPkg:
## 1 = Pre-script failed, package not installed
## 2 = MAJOR fault during property application
## 3 = Minor fault during property application
## 4 = Non-zero exit from a post-script
## 5 = Package is currently suspended
## 6 = No such package
## 7 = Local changes detected during upgrade

def initPkg(pkg,rev=-1):
	global conf
	global options
	global args

	## Get package info from server
	metadict = fetchMetadata(conf['metaurl'])

	## See if the package requested actually exists
	found = False
	for pkgName in metadict['packages']:
		if pkgName == pkg:
			found = True

	## Catch errors
	if not found:
		return 6

	if metadict['packages'][pkg].has_key('desc'):
		packageDescription = metadict['packages'][pkg]['desc']
	else:
		packageDescription = ''

	## SVN
	svnclient = pysvn.Client()

	## Work out paths
	remotePath   = conf['svnroot'] + '/p_' + pkg + '/' 
	localPath    = os.path.join(conf['scsroot'],'packages',pkg)
	localScripts = os.path.join(localPath,'scripts')
	localData    = os.path.join(localPath,'data')
	
	## Get latest remote revision
	infoList = svnclient.info2(remotePath,recurse=False)
	for infoTuple in infoList:
		infoDict = infoTuple[1]
		latestRevision = infoDict['rev']

	## Should we use a speciifc max version? (for channels tagged at a specific version)
	if rev >= 0 and rev <= latestRevision.number:
		latestRevision = pysvn.Revision(pysvn.opt_revision_kind.number, rev)

	## What type, init or upgrade?
	upgrade = False

	## A list of files to ignore during property-apply phase
	ignoreList = []

	## If this is an upgrade
	if packageInstalled(pkg):
		upgrade = True

		## Is the package suspended?

		if isPackageSuspended(pkg):
			error("Package '" + pkg + "' is suspended due to: " + metadataDict['packages'][pkg]['suspend_reason'])
			return 5

		## Get local revision installed
		infoList = svnclient.info2(localData,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			localRevision = infoDict['rev'].number

		if localRevision == latestRevision.number:
			info('Package ' + pkg + ' up to date (revision ' + str(localRevision) + ')')
			return 0
		else:
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, int(localRevision) + 1)

		## TODO FUTURE get revprop to see if we should skip this revision or not

		info('Upgrading ' + pkg + ' to revision ' + str(revisionToUse.number),log=True)

		## Should we ignore local changes?
		ignore = options.ignore

		## If we shouldn't then check for local changes
		if not ignore:
			info('Checking for local changes',log=True)
			(localChangesResult,ignoreList) = checkForLocalChanges(pkg)
			
		## If local changes were detected and we must not proceed because of them...
		if localChangesResult == 3:
			error('One or more files have been changed locally, this must be corrected before upgrading')
			return 7

		## Pre-increment ("pre-upgrade") script
		(scode,sout) = runScript(pkg,'preinc')
		if not scode == 0:
			error(sout)
			error('preinc script returned non-zero, cancelling pkg init')
			return 1

		## Update data now
		debug('Updating package data')
		svnclient.update(localData,revision=revisionToUse)
		
	else:
		revisionToUse = latestRevision
		info('Installing ' + pkg,log=True)

		## Create paths only if they haven't been already
		## This can happen if a pre* script failed
		if not os.path.isdir(localPath):
			## set up directory layout
			try:
				os.mkdir(localPath)
				os.mkdir(os.path.join(localPath,'conf'))
				os.mkdir(os.path.join(localPath,'scripts'))
				os.mkdir(os.path.join(localPath,'data'))
			except (OSError, IOError) as e:
				print 'Failed to init package. Error was: ' + e.strerror + ' on ' + e.filename
				sys.exit(0)

			## Initial check out of data
			debug('Deploying package data')
			svnclient.checkout(remotePath + 'data',localData,revision=revisionToUse)

		else:
			debug('Updating package data')
			svnclient.update(localData,revision=revisionToUse)

	debug('Deploying scripts')
	svnclient.export(remotePath + 'scripts',localScripts,revision=revisionToUse,force=True,recurse=True)

	## Run scripts
	if upgrade:
		(scode,sout) = runScript(pkg,'preup')
		if not scode == 0:
			error(sout)
			error('Script "preup" returned non-zero, cancelling pkg init')
			return 1
	else:
		(scode,sout) = runScript(pkg,'preinit')
		if not scode == 0:
			error(sout)
			error('Script "preinc" returned non-zero, cancelling pkg init')
			return 1

	(scode,sout) = runScript(pkg,'preinst')
	if not scode == 0:
		error(sout)
		error('Script "preinst" returned non-zero, cancelling pkg init')
		return 1

	###### END PRE-SECTION
	###### BEGIN INST-SECTION

	## If anything fails now then we can't/shouldn't stop, but we should mark
	## a failure and then optionally the calling function can suspend the pkg
	## and channel
	faultOccured = False
	faultCode    = 0

	## Get properties
	propList = svnclient.proplist(localData,recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		## Skip files marked as "skip" during check for local changes phase
		if source in ignoreList:
			debug('Skipping file ' + source + ' from inst stage due to local changes')
			continue;

		## By default, apply properties to where the file is downloaded to via SVN
		dest = source

		if 'dest' in properties:
			dest = properties['dest']
			action = 'copy'

			if 'action' in properties:
				action = properties['action']

			if not os.path.islink(dest):
				chattr = subprocess.Popen(['chattr', '-i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
				(stdoutdata, stderrdata) = chattr.communicate()
				retcode = chattr.returncode

				if retcode > 0:
					warn('Unable to remove immutable flag from ' + dest)

			if action == 'copy':
				try:
					shutil.copyfile(source,dest)
				except IOError as e:
					error("Unable to copy from " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'link':
				try:
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					error("Unable to link " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'linkr':
				try:
					if os.path.isdir(dest):
						shutil.rmtree(dest)
					elif os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					error("Unable to linkr " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'linko':
				try:
					if os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					error("Unable to linko " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

		## chmod - set the permissions to octal mode
		if 'chmod' in properties:
			try:
				os.chmod(dest,int(properties['chmod'],8))
			except Exception as e:
				error('Could not apply chmod property to ' + dest + ': ' + str(e))	
				faultOccured = True
				faultCode = 3			

		## owner - set the owner to
		if 'owner' in properties:
			try:
				pwd = pwd.getpwnam(properties['owner'])
				uid = pwd[2]
				os.chown(dest,uid)
			except Exception as e:
				error('Could not apply owner property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3			

		## group - set the group to
		if 'group' in properties:
			try:
				grp = grp.getgrnam(properties['group'])
				gid = grp[2]
				os.chown(dest,-1,gid)
			except Exception as e:
				error('Could not apply group property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3			

		if 'uid' in properties:
			try:
				os.chown(dest,properties['uid'],-1)
			except Exception as e:
				error('Could not apply uid property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3

		## group - set the group to
		if 'gid' in properties:
			try:
				os.chown(dest,-1,properties['gid'])
			except Exception as e:
				error('Could not apply gid property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3

		## immutable - set the file to immutable after
		if 'immutable' in properties:
			## NOTE although python has os.chflags, due to a python configure bug they
			## are NEVER compiled in - stupid python.

			if not os.path.islink(dest):
				chattr = subprocess.Popen(['chattr', '+i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
				(stdoutdata, stderrdata) = chattr.communicate()
				retcode = chattr.returncode

				if retcode > 0:
					error(stdoutdata)
					faultOccured = True
					faultCode = 3
			else:
				warn('Not applying immutable attribute to symlink - not possible')

	###### END INST-SECTION
	###### BEGIN POST-SECTION

	(scode,sout) = runScript(pkg,'postinst')
	if not scode == 0:
		error(sout)
		error('postinst script returned non-zero')
		faultOccured = True
		faultCode = 4

	if upgrade:
		## Pre-upgrade script
		(scode,sout) = runScript(pkg,'postup')
		if not scode == 0:
			error(sout)
			error('postup script returned non-zero')
			faultOccured = True
			faultCode = 4
	else:
		## Post init script
		(scode,sout) = runScript(pkg,'postinit')
		if not scode == 0:
			error(sout)
			error('postinit script returned non-zero')
			faultOccured = True
			faultCode = 4

	###### END POST-SECTION

	## Output some info
	info('Package ' + pkg + ' now at revision ' + str(revisionToUse.number),log=True)

	## update metadata
	metadataDict['packages'][pkg] = { 'name': pkg, 'revision': revisionToUse.number, 'desc': packageDescription}

	if faultOccured:
		error('An error occured during init')
		return faultCode
	else:
		## Recursive call package if we're not at the latest now
		if revisionToUse.number < latestRevision.number:
			return initPkg(pkg)	
		else:
			info('Package ' + pkg + ' now up to date',log=True)
			return 0

################################################################################
################################################################################

def main():
	## Load SVN client
	svnclient = pysvn.Client()

	#### Define the usage text
	usage = '''Usage: %prog [options] ACTION [...]

    Update functions:

        check                      List available updates from channels
        update        CHANNEL      Apply updates from a channel
        update-all                 Apply all updates from all channels

    Basic package functions:

        installed                  List installed packages
        packages                   List all available packages
        init          PACKAGE      Install/upgrade package (Not recommended)
        uninit        PACKAGE      Remove package (Not recommended)
        status        PACKAGE      Show the package status

    Package maintenance functions: 

        verify        PACKAGE      Verify system conforms to package spec
        verify-all                 Verify system conforms to all package specs
        files         PACKAGE      List files which are part of PACKAGE
        files-all                  List files from all packages
        owner         FILEPATH     Determine if FILEPATH is owned by a package
        suspend       CHANNEL      Lock a package so it cannot be updated
        resume        CHANNEL      Unlock a package

    Channel-related actions:
        subscribed                 List channels this system is subscribed to
        channels                   List all available channels 
        subscribe     CHANNEL      Subscribe to a channel
        unsubscribe   CHANNEL      Unsubscribe from a channel

    Other actions:
T       bootstrap                  Set up SCS according to built-in defaults'''

	## Prepare the metadata dictionary (local)
	global metadataDict
	metadataDict = None
	
	## Log variable
	global logOpened
	logOpened = False

	## Set a 'good' working directory
	os.chdir('/tmp')

	#### Parse command line options
	parser = OptionParser(usage=usage,version='%prog version 3')
	parser.add_option('-c','--config-file',dest='config',default="/etc/scs.conf",help='Set the configuration file to use')
	parser.add_option('-f','--force',dest='ignore',default=False,action="store_true",help='Ignore local changes and proceed anyway')
	parser.add_option('-d','--debug',dest='debug',default=False,action="store_true",help='Print debug messages during execution')
	parser.add_option('-q','--quiet',dest='quiet',default=False,action="store_true",help='Print no output except in the case of error')
	group = OptionGroup(parser,"Options for 'init'")
	group.add_option('-r','--revision',type="int",default=-1,dest='revision',help='Specify a specific revision of the package to tag')
	parser.add_option_group(group)

	global options
	global args
	(options, args) = parser.parse_args()

	#### LOAD CONFIG
	config = ConfigParser.RawConfigParser()
	config.read(options.config)

	global conf
	conf = {}
	conf['scsroot']  = '/opt/scs/'
	conf['svnroot']  = ''
	conf['metaurl']  = ''
	conf['smtp']     = 'rcfg.soton.ac.uk'
	#conf['mailaddr'] = None
	conf['mailaddr'] = 'notify@scs.soton.ac.uk'
	
	## log file
	if config.has_option('client','log file'):
		openLog(config.get('client','log file'))
	else:
		openLog('/var/log/scs.log')
	
	## scs root
	if config.has_option('client','scs root'):
		configValue = config.get('client','scs root')
		if os.path.isdir(configValue):
			conf['scsroot'] = configValue
		else:
			fatal('The scs root specified in ' + options.config + ' is not a directory')

	## svn root
	if config.has_option('client','svn root'):
		conf['svnroot'] = config.get('client','svn root')
	else:
		fatal('No svn root defined in ' + options.config)

	if config.has_option('client','metadata url'):
		conf['metaurl'] = config.get('client','metadata url')
	else:
		fatal('No metadata url defined in ' + options.config)
		
	## email options
	if config.has_option('client','smtp server'):
		configValue = config.get('client','smtp server')
		conf['smtp'] = configValue
	if config.has_option('client','notify email'):
		configValue = config.get('client','notify email')
		conf['mailaddr'] = configValue		

	#### LOCK AND LOAD METADATA
	## Open metadata file, lock it, and read contents
	global metadataFile
	metadataPath = os.path.join(conf['scsroot'],'client.meta')
	try:
		## Create client.meta if it does not exist
		if not os.path.isfile(metadataPath):
			open(metadataPath,'w')
			
		metadataFile = open(metadataPath,'r+')
		fcntl.lockf(metadataFile,fcntl.LOCK_EX | fcntl.LOCK_NB)
		
	except (IOError, OSError) as exception:
		if exception.errno == errno.EAGAIN or exception.errno == errno.EACCES:
			fatal('Sorry, another process is currently executing - try again later')
		else:
			fatal('Unable to lock ' + str(exception.filename) + ': ' + str(exception.strerror))

	try:
		jsonData = metadataFile.read()
		metadataFile.seek(0)
	except (IOError, OSError) as e:
		fatal('Unable to read from ' + e.filename + ': ' + e.strerror)

	## Handle empty data
	if len(jsonData) == 0:
		metadataDict = {'channels': {}, 'packages': {}}
	else:
		## Turn json data into python objects
		try:
			metadataDict = json.loads(jsonData)
		except (TypeError,ValueError) as e:
			fatal('Unable to understand metadata: ' + str(e))

	#### SWTICH ACTIONS
	if len(args) < 1:
		parser.print_help()
	else:
		action = args[0]

################################################################################

		if action == 'installed':
			output = ''
			looped = False
			for pkg in metadataDict['packages']:

				if not looped:
					printPackageHeader()
					looped = True

				printPackageInfo(pkg)

################################################################################

		elif action == 'packages':
			metadict = fetchMetadata(conf['metaurl'])
			output = ''
			for pkgName in metadict['packages']:
				data = metadict['packages'][pkgName]
				if type(data).__name__=='dict':
				
					## Get the latest channel revision
					remotePath  = conf['svnroot'] + '/p_' + pkgName + '/'

					## Get the latest revision of the package
					infoList = svnclient.info2(remotePath,recurse=False)
					for infoTuple in infoList:
						infoDict = infoTuple[1]
						latestRevision = infoDict['rev']
						
					if data.has_key('name') and data.has_key('desc'):
						output += "{0:14}  {1:15}  {2:37}\n".format(str(data['name']), str(latestRevision.number), str(data['desc']))
					elif data.has_key('name'):
						output += "{0:14}  {1:15}  {2:37}\n".format(str(data['name']), str(latestRevision.number), 'N/A')
					else:
						fatal('Unable to understand data: ' + str(e))
				else:
					fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:14}  {1:15}  {2:37}'.format('PACKAGE NAME','LATEST REVISION','DESCRIPTION')
				print '{0:14}  {1:15}  {2:37}'.format('------------','---------------','-----------')
				sys.stdout.write(output)

################################################################################

		elif action == 'status' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				data = metadataDict['packages'][pkg]

				print '           Name: ' + data['name']
				print ' Local Revision: ' + str(data['revision'])

				if data.has_key('desc'):		
					print '    Description: ' + data['desc']

				if isPackageSuspended(pkg):
					print '         Status: SUSPENDED'
					if data.has_key('suspend_reason'):
						print '        Reason: ' + data['suspend_reason']
				else:
					print '         Status: OK'
			else:
				fatal('Package not installed',log=False)

		elif action == 'suspend' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				if isPackageSuspended(pkg):
					fatal('Package is already suspended',log=False)
				else:
					suspendPackage(pkg,'Suspended by system administrator')
			else:
				fatal('Package not installed',log=False)

		elif action == 'resume' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				if isPackageSuspended(pkg):
					resumePackage(pkg)
				else:
					fatal('Package is not suspended',log=False)
			else:
				fatal('Package not installed',log=False)

		elif action == 'verify' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')
				checkForLocalChanges(pkg)
			else:
				fatal('Package not installed',log=False)

		elif action == 'verify' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')
				checkForLocalChanges(pkg)
			else:
				fatal('Package not installed',log=False)

################################################################################

		elif action == 'verify-all':
			pkgs = os.listdir(os.path.join(conf['scsroot'],'packages'))
			for pkg in pkgs:
				output('Checking for local changes to pkg "' + pkg + '"')
				checkForLocalChanges(pkg)

################################################################################

		elif action == 'files' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')
				listFiles(pkg)
			else:
				fatal('No such package')

################################################################################

		elif action == 'files-all':
			pkgs = os.listdir(os.path.join(conf['scsroot'],'packages'))
			for pkg in pkgs:
				output(pkg + ':')
				listFiles(pkg)

################################################################################

		elif action == 'owner' and len(args) == 2:
			f = args[1]
			pkgs = os.listdir(os.path.join(conf['scsroot'],'packages'))
			for pkg in pkgs:
				propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)

				for propSet in propList:
					source     = propSet[0]
					properties = propSet[1]

					if 'dest' in properties:
						dest = properties['dest']

						if dest == f:
							print pkg

#################################################################################

		elif action == 'init' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			## Get metadata from server
			metadict = fetchMetadata(conf['metaurl'])

			## See if the package requested actually exists
			found = False
			for pkgName in metadict['packages']:
				if pkgName == pkg:
					found = True

			## Catch errors
			if not found:
				fatal('No such package on server')

			initPkg(pkg)

################################################################################

		elif action == 'uninit' and len(args) == 2:
			pkg = args[1]
			if packageInstalled(pkg):
				uninitPkg(pkg)

################################################################################

		elif action == 'channels':
			metadict = fetchMetadata(conf['metaurl'])
			output = ''
			for cName in metadict['channels']:
				data = metadict['channels'][cName]
				if type(data).__name__=='dict':
				
					## Get the latest channel revision
					remotePath  = conf['svnroot'] + '/c_' + cName + '/'

					## Get the latest revision of the package
					infoList = svnclient.info2(remotePath,recurse=False)
					for infoTuple in infoList:
						infoDict = infoTuple[1]
						latestRevision = infoDict['rev']
				
					if data.has_key('name') and data.has_key('desc'):
						output += "{0:14}  {1:15}  {2:37}\n".format(str(data['name']), str(latestRevision.number), str(data['desc']))
					elif data.has_key('name'):
						output += "{0:14}  {1:15}  {2:37}\n".format(str(data['name']), str(latestRevision.number), 'N/A')
					else:
						fatal('Unable to understand data: ' + str(e))
				else:
					fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:14}  {1:15}  {2:37}'.format('CHANNEL NAME','LATEST REVISION','DESCRIPTION')
				print '{0:14}  {1:15}  {2:37}'.format('------------','---------------','-----------')
				sys.stdout.write(output)					

################################################################################

		elif action == 'subscribed':
			output = ''
			for channel in metadataDict['channels']:
				data = metadataDict['channels'][channel]
				if type(data).__name__=='dict':
					if data.has_key('name') and data.has_key('revision') and data.has_key('desc'):
						output += '{0:24}    {1:24}    {2:24}'.format(str(data['name']), str(data['revision']), str(data['desc']))
					elif data.has_key('name') and data.has_key('revision'):
						output += '{0:24}    {1:24}'.format(str(data['name']), str(data['revision']))
					else:
						fatal('Unable to understand data: ' + str(e))
				else:
					fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('CHANNEL NAME','LOCAL REVISION','DESCRIPTION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','--------------','-----------')
				print output

################################################################################

		elif action == 'subscribe' and len(args) == 2:
			channel    = args[1]
			remotePath = conf['svnroot'] + '/c_' + channel + '/'
			localPath  = os.path.join(conf['scsroot'],'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')

			## Get package info from server
			metadict = fetchMetadata(conf['metaurl'])

			## See if the package requested actually exists
			found = False
			for channelName in metadict['channels']:
				if channelName == channel:
					found = True

			## Catch errors
			if not found:
				fatal('No such channel exists on the server')

			if metadict['channels'][channel].has_key('desc'):
				channelDescription = metadict['channels'][pkg]['desc']
			else:
				channelDescription = ''

			if channelSubscribed(channel):
				info("Already subscribed to channel")
			else:

				if not os.path.isdir(localPath):
					## set up directory layout
					## but only if it isn't there
					## this can happen if subscribe fails
					try:
						os.mkdir(localPath)
						os.mkdir(localPkgs)
					except (OSError, IOError) as error:
						print 'Failed to subscribe to channel. Error was: ' + error.strerror + ' on ' + error.filename
						sys.exit(0)

					## Download package information
					svnclient.checkout(remotePath + 'packages',localPkgs)
				else:
					## Update package information
					svnclient.update(localPkgs)

				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				## If errors occured we should suspend the ch

				pkgList = []

				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to install order
				## use -pkg[0] for reverse
				pkgList = sorted(pkgList, key=lambda pkg: pkg[0])
				
				for pkgT in pkgList:
					result = initPkg(pkgT[1],rev=pkgT[2])

					## Result of pkgInit
					if result > 0:
						if result == 1:
							## Failed to init package, thus the channel subscribe has failed!
							fatal("Could not subscribe from channel. Please correct the error and try to subscribe again")
						else:
							if result == 2:
								suspendPackage(pkgT[1],"A major fault occured when applying package properties")
							elif result == 3:
								suspendPackage(pkgT[1],"A minor fault occured when applying package properties")
							elif result == 4:
								suspendPackage(pkgT[1],"A post script returned an error after package installation")
							elif result == 5:
								fatal("Package is currently suspended. Could not subscribe to channel.")
							elif result == 6:
								fatal("Package does not exist. Could not subscribe to channel.")
							elif result == 7:
								suspendPackage(pkgT[1],"One or more files have been changed locally")

							fatal("Package suspended. Could not subscribe to channel.")

				## What revision did we just subscribe to?
				infoList = svnclient.info2(localPkgs,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					localRevision = infoDict['rev'].number

				## Update metadata
				metadataDict['channels'][channel] = { 'name': channel, 'revision': localRevision, 'desc' : channelDescription}

				## Output
				info('Subscribed to channel ' + channel + ' - at revision ' + str(localRevision),log=True)

################################################################################

		elif action == 'unsubscribe':
			channel    = args[1]
			localPath  = os.path.join(conf['scsroot'],'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')

			if not channelSubscribed(channel):
				fatal("Not subscribed to that channel",log=False)
			else:
				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				pkgList = []

				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to remove order
				pkgList = sorted(pkgList, key=lambda pkg: -pkg[0])
				
				for pkgT in pkgList:
					result = uninitPkg(pkgT[1])

					if result == 1:
						## Failed to remove, could not unsubscribe!
						fatal("Could not unsubscribe from channel. Please correct the error and try to unsubscribe again")
						
				## Delete data
				shutil.rmtree(localPath)

				## Update metadata
				del(metadataDict['channels'][channel])

				## Output
				info('Unsubscribed from channel ' + channel,log=True)

################################################################################

		elif action == 'check':
			output = ''

			for channel in metadataDict['channels']:
				remotePath   = conf['svnroot'] + '/c_' + channel + '/'

				## Get latest remote revision
				infoList = svnclient.info2(remotePath,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					latestRevision = infoDict['rev']

				if latestRevision.number > int(metadataDict['channels'][channel]['revision']):
					output += '{0:24}    {1:24}    {2:24}'.format(channel,str(latestRevision.number), str(metadataDict['channels'][channel]['revision']))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('CHANNEL NAME','LATEST REVISION','LOCAL REVISION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','---------------','--------------')
				print output

################################################################################

		elif action == 'update' and len(args) == 2:
			channel = args[1]
			updateChannel(channel)

		elif action == 'update-all':
			channels = os.listdir(os.path.join(conf['scsroot'],'channels'))
			for channel in channels:
				updateChannel(channel)

################################################################################

		else:
			parser.print_help()

		saveMetadata()

################################################################################

if __name__ == "__main__":
    main()

