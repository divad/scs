#!/usr/bin/python

import os
import stat
import json
import sys
import urllib
import pysvn
import subprocess
import shutil
import pwd
import grp
import hashlib
import ConfigParser
from optparse import OptionParser, OptionGroup
import fcntl

#### TODO TODO TODO TODO
# TODO bootstrap?? maybe.
# TODO log runScripts? print in verbose mode?						IMPORTANT
# TODO pause channel??												IMPORTANT
# TODO Use revprop for skipping channel or package revisions?		FUTURE VERSION

################################################################################
################################################################################

def verbose(o,verbosity):
	global verboseLevel

	if verboseLevel >= verbosity:
		print 'SCS: ' + str(o)

################################################################################
################################################################################

def output(o):
	print 'SCS: ' + str(o)

################################################################################
################################################################################

def fatal(o,exitcode=1):
	sys.stderr.write('SCS: ' + str(o) + "\n")
	sys.exit(exitcode)

################################################################################
################################################################################

## "check" property
### before increment it checks all files with "check" property
#### check value can be:
#### - fail - Fail the entire package upgrade if the local file has changed - DOES NOT OVERWRITE
#### - ignore - (default) - Do nothing - don't care - OVERWITES LOCAL CHANGES
#### - warn - Warn the file has changed - OVERWRITES LOCAL CHANGES
#### - skip - don't change /that/ file, and that file alone, on the next increment - DOES NOT OVERWRITE
def checkForLocalChanges(pkg):
	global scsroot
	ignoreList = []
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(scsroot,'packages',pkg,'data'),recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']

			verbose('Checking for local changes on ' + dest,3)

			## Get SHA sums
			try:
				sourceh = shasum(source)
				desth   = shasum(dest)
			except Exception as e:
				output('Cannot check for local changes on ' + dest + ': ' + str(e))
			else:
				## Compare sums
				if not sourceh == desth:

					verbose('The file ' + dest + ' has been modified outside of SCS control',1)

					## TODO FUTURE make the default come from a revprop?
					checkAction = 'ignore'

					if 'check' in properties:
						checkAction = properties['check']

					verbose('The file has been configured to "' + checkAction + '" in this scenario',2)

					if checkAction == 'fail':
						output("ERROR! Local changes found to file " + dest)
						output("ERROR! Transaction failed. Could not init pkg")
						return 1
					elif checkAction == 'warn':
						output("WARNING! Local changes found to file " + dest)
					elif checkAction == 'skip':
						## add the file to the "ignore" list
						ignoreList.append(source)

	return ignoreList

################################################################################
################################################################################

def packageInstalled(pkg):
	global metadataDict

	if metadataDict['packages'].has_key(pkg):
		return True
	else:
		return False

################################################################################
################################################################################

def channelSubscribed(channel):
	global metadataDict

	if metadataDict['channels'].has_key(channel):
		return True
	else:
		return False

################################################################################
################################################################################

def listFiles(pkg):
	global scsroot
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(scsroot,'packages',pkg,'data'),recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']
			print '{0:38}  {1:38}'.format(dest, source)

################################################################################
################################################################################

def shasum(filePath,blocksize=2**20):
	sha = hashlib.sha256()
	f = open(filePath,'rb')
	while True:
		data = f.read(blocksize)
		if not data:
			break;
		sha.update(data)
	return sha.hexdigest()

################################################################################
################################################################################

def runScript(pkgName,scriptName):
	global scsroot
	verbose('Executing ' + scriptName,2)
	scriptPath = os.path.join(scsroot,'packages',pkgName,'scripts',scriptName)

	## CHMOD First
	os.chmod(scriptPath,stat.S_IRWXU)

	if os.path.getsize(scriptPath) == 0:
		verbose("Script is empty; not executing",3)
		return (0, '', '')

	## Now run the script
	try:
		script = subprocess.Popen([scriptPath],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		(stdoutdata, stderrdata) = script.communicate()
		return (script.returncode, stdoutdata, stderrdata)
	except OSError as e:
		## UNIX codes will only ever be 0-255
		## Thus use -1 to signify an OS error
		output('Execution of script ' + scriptName + ' failed: ' + str(e))
		return (-1,str(e),str(e))

################################################################################
################################################################################

def fetchMetadata(metadataUrl):
	verbose('Fetching metadata from server',3)
	try:
		f = urllib.urlopen(metadataUrl)
		jsonData = f.read()
		f.close()
	except IOError as e:
		fatal('Unable to read from ' + e.filename + ': ' + e.strerror)

	try:
		metadict = json.loads(jsonData)
	except (TypeError,ValueError) as e:
		fatal('Unable to understand server metadata: ' + str(e))

	return metadict

################################################################################
################################################################################

def uninitPkg(pkg):
	global scsroot

	if packageInstalled(pkg):
		(scode,sout,serr) = runScript(pkg,'uninit')
		if not scode == 0:
			output('Script "uninit" returned non-zero')
			return 1
		else:
			## Delete data
			shutil.rmtree(os.path.join(scsroot,'packages',pkg))

			## Update metadata
			del(metadataDict['packages'][pkg])

			## Output
			verbose('Removed package "' + pkg + '"',1)
	
			## Return OK
			return 0
	else:
		verbose('Package "' + pkg + '" not installed so not removing',1)
		return 0

################################################################################
################################################################################

# results
# 0 OK!
# 1 Could not upgrade
def updateChannel(channel):
	verbose('updateChannel() called',5)

	svnclient = pysvn.Client()

	if channelSubscribed(channel):	
		remotePath  = svnroot + '/c_' + channel + '/'
		localPath   = os.path.join(scsroot,'channels',channel)
		localPkgs   = os.path.join(localPath,'packages')
		upgradeFile = remotePath + 'upgrade'

		## Get the latest revision of the channel
		infoList = svnclient.info2(remotePath,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			latestRevision = infoDict['rev']

		verbose('updateChannel: Latest remote revision is ' + str(latestRevision.number),5)

		## Get the installed revision
		infoList = svnclient.info2(localPkgs,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			localRevision = infoDict['rev']

		verbose('updateChannel: Latest local revision is ' + str(localRevision.number),5)

		## Decide upon which revision to go to????
		if localRevision.number == latestRevision.number:
			output('Channel "' + channel + '" is up to date')
			return
		else:
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, localRevision.number + 1)

		## No need to download the upgrade file, we'll just read its properties from remote :)
		## Get the properties
		propList = svnclient.proplist(upgradeFile,revision=revisionToUse)

		for propSet in propList:
			properties = propSet[1]

			if properties.has_key('name') and properties.has_key('revision') and properties.has_key('action'):
				if properties['action'] == 'install':
					## Install 'revision' of 'name'
					result = initPkg(properties['name'],int(properties['revision']))

					## Result of pkgInit
					if result > 0:
						if result == 1:
							## Failed to init package, thus the channel upgrade has failed!
							fatal("Could not upgrade channel. Please correct the error and try to upgrade again")
							return 1
						else:
							print 'blargh'
							## Channel subscribed...but there were problems. TODO PAUSE CHANNEL?

			elif properties.has_key('name') and properties.has_key('action'):
				if properties['action'] == 'remove':
					## Remove 
					result = uninitPkg(properties['name'])

					if result == 1:
						fatal("Could not upgrade channel. Please correct the error and try to upgrade again")
						return 1
					
			else:
				verbose('Warning! Channel upgrade file does not have properties set against it!',1)

		## Update packages (Although we don't actually use them until an unsubscribe - but they are there if an admin wants them)
		## NOTE! Updating this means SCS will think the channel is updated, hence why we do it here.
		svnclient.update(localPkgs,revision=revisionToUse)

		## TODO save meta? Then use meta to know what the local revision is? DUH...

		## We're upgraded
		if revisionToUse.number < latestRevision:
			## We need to recursive-call and upgrade again! :)
			updateChannel(channel)
		else:
			## We're done!
			return 0

	else:
		fatal('Not subscribed to channel ' + channel)

################################################################################
################################################################################

#### RETURN CODES for initPkg:
## 1 = Pre-script failed, package not installed
## 2 = MAJOR fault during inst
## 3 = Minor fault during inst
## 4 = Non-zero exit from a post-script

def initPkg(pkg,rev=-1):
	global scsroot
	global svnroot
	global options
	global args

	## SVN
	svnclient = pysvn.Client()

	## Work out paths
	remotePath   = svnroot + '/p_' + pkg + '/' 
	localPath    = os.path.join(scsroot,'packages',pkg)
	localScripts = os.path.join(localPath,'scripts')
	localData    = os.path.join(localPath,'data')
	
	## Get latest remote revision
	infoList = svnclient.info2(remotePath,recurse=False)
	for infoTuple in infoList:
		infoDict = infoTuple[1]
		latestRevision = infoDict['rev']

	## Should we use a speciifc max version? (for channels tagged at a specific version)
	if rev >= 0 and rev <= latestRevision.number:
		latestRevision = pysvn.Revision(pysvn.opt_revision_kind.number, rev)

	## What type, init or upgrade?
	upgrade = False

	## A list of files to ignore during property-apply phase
	ignoreList = []

	## If this is an upgrade
	if packageInstalled(pkg):
		upgrade = True

		## Get local revision installed
		infoList = svnclient.info2(localData,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			localRevision = infoDict['rev'].number

		if localRevision == latestRevision.number:
			verbose('Package ' + pkg + ' up to date (revision ' + str(localRevision) + ')',1)
			return 0
		else:
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, int(localRevision) + 1)

		## TODO FUTURE get revprop to see if we should skip this revision or not

		verbose('Upgrading ' + pkg + ' to revision ' + str(revisionToUse.number),1)

		## Should we ignore local changes?
		ignore = options.ignore

		## If we shouldn't then check for local changes
		if not ignore:
			verbose('Checking for local changes',1)
			ignoreList = checkForLocalChanges(pkg)

		## Pre-increment ("pre-upgrade") script
		(scode,sout,serr) = runScript(pkg,'preinc')
		if not scode == 0:
			output('preinc script returned non-zero, cancelling pkg init')
			return 1

		## Update data now
		verbose('Updating package data',2)
		svnclient.update(localData,revision=revisionToUse)
		
	else:
		revisionToUse = latestRevision
		verbose('Installing ' + pkg,1)

		## Create paths only if they haven't been already
		## This can happen if a pre* script failed
		if not os.path.isdir(localPath):
			## set up directory layout
			try:
				os.mkdir(localPath)
				os.mkdir(os.path.join(localPath,'conf'))
				os.mkdir(os.path.join(localPath,'scripts'))
				os.mkdir(os.path.join(localPath,'data'))
			except (OSError, IOError) as error:
				print 'Failed to init package. Error was: ' + error.strerror + ' on ' + error.filename
				sys.exit(0)

			## Initial check out of data
			verbose('Deploying package data',2)
			svnclient.checkout(remotePath + 'data',localData,revision=revisionToUse)

		else:
			verbose('Updating package data',2)
			svnclient.update(localData,revision=revisionToUse)

	verbose('Deploying scripts',2)
	svnclient.export(remotePath + 'scripts',localScripts,revision=revisionToUse,force=True,recurse=True)

	## Run scripts
	if upgrade:
		(scode,sout,serr) = runScript(pkg,'preup')
		if not scode == 0:
			output('Script "preup" returned non-zero, cancelling pkg init')
			return 1
	else:
		(scode,sout,serr) = runScript(pkg,'preinit')
		if not scode == 0:
			output('Script "preinc" returned non-zero, cancelling pkg init')
			return 1

	(scode,sout,serr) = runScript(pkg,'preinst')
	if not scode == 0:
		output('Script "preinst" returned non-zero, cancelling pkg init')
		return 1

	###### END PRE-SECTION
	###### BEGIN INST-SECTION

	## If anything fails now then we can't/shouldn't stop, but we should mark
	## a failure and then optionally the calling function can suspend the pkg
	## and channel
	faultOccured = False
	faultCode    = 0

	## Get properties
	propList = svnclient.proplist(localData,recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		## Skip files marked as "skip" during check for local changes phase
		if source in ignoreList:
			verbose('Skipping file ' + source + ' from inst stage due to local changes',1)
			continue;

		## By default, apply properties to where the file is downloaded to via SVN
		dest = source

		if 'dest' in properties:
			dest = properties['dest']
			action = 'copy'

			if 'action' in properties:
				action = properties['action']

			if not os.path.islink(dest):
				chattr = subprocess.Popen(['chattr', '-i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
				(stdoutdata, stderrdata) = chattr.communicate()
				retcode = chattr.returncode

				if retcode > 0:
					output('Unable to remove immutable flag from ' + dest)

			if action == 'copy':
				try:
					shutil.copyfile(source,dest)
				except IOError as e:
					output("Unable to copy from " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'link':
				try:
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					output("Unable to link " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'linkr':
				try:
					if os.path.isdir(dest):
						shutil.rmtree(dest)
					elif os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					output("Unable to linkr " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

			elif action == 'linko':
				try:
					if os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					output("Unable to linko " + source + " to " + dest + ": " + str(e))
					faultOccured = True
					faultCode = 2

		## chmod - set the permissions to octal mode
		if 'chmod' in properties:
			try:
				os.chmod(dest,int(properties['chmod'],8))
			except Exception as e:
				output('Could not apply chmod property to ' + dest + ': ' + str(e))	
				faultOccured = True
				faultCode = 3			

		## owner - set the owner to
		if 'owner' in properties:
			try:
				pwd = pwd.getpwnam(properties['owner'])
				uid = pwd[2]
				os.chown(dest,uid)
			except Exception as e:
				output('Could not apply owner property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3			

		## group - set the group to
		if 'group' in properties:
			try:
				grp = grp.getgrnam(properties['group'])
				gid = grp[2]
				os.chown(dest,-1,gid)
			except Exception as e:
				output('Could not apply group property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3			

		if 'uid' in properties:
			try:
				os.chown(dest,properties['uid'],-1)
			except Exception as e:
				output('Could not apply uid property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3

		## group - set the group to
		if 'gid' in properties:
			try:
				os.chown(dest,-1,properties['gid'])
			except Exception as e:
				output('Could not apply gid property to ' + dest + ': ' + str(e))
				faultOccured = True
				faultCode = 3

		## immutable - set the file to immutable after
		if 'immutable' in properties:
			## NOTE although python has os.chflags, due to a python configure bug they
			## are NEVER compiled in - stupid python.

			if not os.path.islink(dest):
				chattr = subprocess.Popen(['chattr', '+i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
				(stdoutdata, stderrdata) = chattr.communicate()
				retcode = chattr.returncode

				if retcode > 0:
					output(stdoutdata + "\n" + stderrdata)
					faultOccured = True
					faultCode = 3
			else:
				output('Not applying immutable attribute to symlink - not possible')

	###### END INST-SECTION
	###### BEGIN POST-SECTION

	(scode,sout,serr) = runScript(pkg,'postinst')
	if not scode == 0:
		output('postinst script returned non-zero')
		faultOccured = True
		faultCode = 4

	if upgrade:
		## Pre-upgrade script
		(scode,sout,serr) = runScript(pkg,'postup')
		if not scode == 0:
			output('postup script returned non-zero')
			faultOccured = True
			faultCode = 4
	else:
		## Post init script
		(scode,sout,serr) = runScript(pkg,'postinit')
		if not scode == 0:
			output('postinit script returned non-zero')
			faultOccured = True
			faultCode = 4

	###### END POST-SECTION

	## Build metadata
	pkgMeta = {
					'name': pkg,
					'revision': str(revisionToUse.number),
					'desc': 'Fake desc'
				}

	## Convert metadata to json
	jsonOut = json.dumps(pkgMeta, sort_keys=True, indent=4)

	## Write the metadata
	try:
		f = open(os.path.join(scsroot,'packages',pkg,'conf','metadata.json'),'w')
		f.write(jsonOut)
		f.write("\n")
		f.close()
	except Exception as e:
		fatal('Unable to write to ' + pkg + ' metadata file: ' + str(e))

	## Output some info
	verbose('Package ' + pkg + ' now at revision ' + str(revisionToUse.number),1)

	## update metadata
	metadataDict['packages'][pkg] = { 'name': pkg, 'revision': revisionToUse.number, 'desc': 'Random fake desc'}

	if faultOccured:
		output('An error occured during init')
		return faultCode
	else:
		## Recursive call package if we're not at the latest now
		if revisionToUse.number < latestRevision.number:
			return initPkg(pkg)	
		else:
			verbose('Package ' + pkg + ' now up to date',1)
			return 0

################################################################################
################################################################################

def main():
	#### HELP TEXT FOR ACTIONS
	usage = '''Usage: %prog [options] ACTION [...]

    Update functions:

        check                      List available updates from channels
        update        CHANNEL      Apply updates from a channel
        update-all                 Apply all updates from all channels

    Basic package functions:

        installed                  List installed packages
        packages                   List all available packages
        init          PACKAGE      Install/upgrade package (Not recommended)
        uninit        PACKAGE      Remove package (Not recommended)

    Package maintenance functions: 

        verify        PACKAGE      Verify system conforms to package spec
        verify-all                 Verify system conforms to all package specs
		files         PACKAGE      List files which are part of PACKAGE
        files-all                  List files from all packages
        owner         FILEPATH     Determine if FILEPATH is owned by a package

    Channel-related actions:
        subscribed                 List channels this system is subscribed to
        channels                   List all available channels 
        subscribe     CHANNEL      Subscribe to a channel
        unsubscribe   CHANNEL      Unsubscribe from a channel

    Other actions:
T       bootstrap                  Set up SCS according to the defaults'''

	## Set a 'good' working directory
	os.chdir('/tmp')

	#### COMMAND LINE PARSER
	parser = OptionParser(usage=usage,version='%prog version 2')
	parser.add_option('-v',dest='verboseLevel',action="count",help='Set verbose level, use multiple times to increase verbosity')
	parser.add_option('-c','--config-file',dest='config',default="/etc/scs.conf",help='Set the configuration file to use')
	parser.add_option('-f','--force',dest='ignore',default=False,action="store_true",help='Ignore local changes and proceed anyway')
	group = OptionGroup(parser,"Options for 'init'")
	group.add_option('-r','--revision',type="int",default=-1,dest='revision',help='Specify a specific revision of the package to tag')
	parser.add_option_group(group)

	global options
	global args
	(options, args) = parser.parse_args()

	#### VERBOSITY
	global verboseLevel
	verboseLevel = options.verboseLevel

	#### LOAD CONFIG
	config = ConfigParser.RawConfigParser()
	config.read(options.config)

	global scsroot
	global svnroot
	global metaurl

	scsroot  = '/opt/scs/'
	svnroot  = ''
	metaurl  = ''

	if config.has_option('client','scs root'):
		configValue = config.get('client','scs root')
		if os.path.isdir(configValue):
			scsroot = configValue
			verbose('Setting scsroot to ' + configValue,3)
		else:
			fatal('The scs root specified in ' + options.config + ' is not a directory')

	if config.has_option('client','svn root'):
		svnroot = config.get('client','svn root')
	else:
		fatal('No svn root defined in ' + options.config)

	if config.has_option('client','metadata url'):
		metaurl = config.get('client','metadata url')
	else:
		fatal('No metadata url defined in ' + options.config)

	#### LOCK AND LOAD METADATA
	## Open metadata file, lock it, and read contents
	metadataPath = os.path.join(scsroot,'client.meta')
	try:
		## Create client.meta if it does not exist
		if not os.path.isfile(metadataPath):
			open(metadataPath,'w')

		metadataFile = open(metadataPath,'r+')
		fcntl.flock(metadataFile,fcntl.LOCK_EX)
	except (IOError, OSError) as e:
		fatal('Unable to lock ' + str(e.filename) + ': ' + str(e.strerror))

	try:
		jsonData = metadataFile.read()
		metadataFile.seek(0)
	except (IOError, OSError) as e:
		fcntl.flock(metadataFile,fcntl.LOCK_UN)
		fatal('Unable to read from ' + e.filename + ': ' + e.strerror)

	global metadataDict

	## Handle empty data
	if len(jsonData) == 0:
		metadataDict = {'channels': {}, 'packages': {}}
	else:
		## Turn json data into python objects
		try:
			metadataDict = json.loads(jsonData)
		except (TypeError,ValueError) as e:
			fcntl.flock(metadataFile,fcntl.LOCK_UN)
			fatal('Unable to understand metadata: ' + str(e))

	#### SWTICH ACTIONS
	if len(args) < 1:
		parser.print_help()
	else:
		action = args[0]

################################################################################

		if action == 'installed':
			output = ''
			for pkg in metadataDict['packages']:
				data = metadataDict['packages'][pkg]
				if type(data).__name__=='dict':
					if data.has_key('name') and data.has_key('revision') and data.has_key('desc'):
						output += '{0:24}    {1:24}    {2:24}'.format(str(data['name']), str(data['revision']), str(data['desc']))
					elif data.has_key('name') and data.has_key('revision'):
						output += '{0:24}    {1:24}'.format(str(data['name']), str(data['revision']))
					else:
						fatal('Unable to understand data: ' + str(e))
				else:
					fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('PACKAGE NAME','LOCAL REVISION','DESCRIPTION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','--------------','-----------')
				print output

################################################################################

		elif action == 'packages':
			metadict = fetchMetadata(metaurl)

			for pkgName in metadict['packages']:
				pkg = metadict['packages'][pkgName]
				if pkg.has_key('name'):
					print(pkg['name'])

				## TODO add latest revision by querying it?

################################################################################

		elif action == 'verify' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(scsroot,'packages',pkg,'data')
				checkForLocalChanges(pkg)
			else:
				fatal('No such package')

################################################################################

		elif action == 'verify-all':
			pkgs = os.listdir(os.path.join(scsroot,'packages'))
			for pkg in pkgs:
				output('Checking for local changes to pkg "' + pkg + '"')
				checkForLocalChanges(pkg)

################################################################################

		elif action == 'files' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(scsroot,'packages',pkg,'data')
				listFiles(pkg)
			else:
				fatal('No such package')

################################################################################

		elif action == 'files-all':
			pkgs = os.listdir(os.path.join(scsroot,'packages'))
			for pkg in pkgs:
				output(pkg + ':')
				listFiles(pkg)

################################################################################

		elif action == 'owner' and len(args) == 2:
			f = args[1]
			svnclient = pysvn.Client()
			pkgs = os.listdir(os.path.join(scsroot,'packages'))
			for pkg in pkgs:
				propList = svnclient.proplist(os.path.join(scsroot,'packages',pkg,'data'),recurse=True)

				for propSet in propList:
					source     = propSet[0]
					properties = propSet[1]

					if 'dest' in properties:
						dest = properties['dest']

						if dest == f:
							print pkg

#################################################################################

		elif action == 'init' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			## Get metadata from server
			metadict = fetchMetadata(metaurl)

			## See if the package requested actually exists
			found = False
			for pkgName in metadict['packages']:
				if pkgName == pkg:
					found = True

			## Catch errors
			if not found:
				fatal('No such package on server')

			initPkg(pkg)

################################################################################

		elif action == 'uninit' and len(args) == 2:
			pkg = args[1]
			if packageInstalled(pkg):
				uninitPkg(pkg)

################################################################################

		elif action == 'channels':
			metadict = fetchMetadata(metaurl)

			for cName in metadict['channels']:
				channel = metadict['channels'][cName]
				if channel.has_key('name'):
					print str(channel['name'])

################################################################################

		elif action == 'subscribed':
			output = ''
			for channel in metadataDict['channels']:
				data = metadataDict['channels'][channel]
				if type(data).__name__=='dict':
					if data.has_key('name') and data.has_key('revision') and data.has_key('desc'):
						output += '{0:24}    {1:24}    {2:24}'.format(str(data['name']), str(data['revision']), str(data['desc']))
					elif data.has_key('name') and data.has_key('revision'):
						output += '{0:24}    {1:24}'.format(str(data['name']), str(data['revision']))
					else:
						fatal('Unable to understand data: ' + str(e))
				else:
					fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('CHANNEL NAME','LOCAL REVISION','DESCRIPTION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','--------------','-----------')
				print output

################################################################################

		elif action == 'subscribe' and len(args) == 2:
			channel    = args[1]
			remotePath = svnroot + '/c_' + channel + '/'
			localPath  = os.path.join(scsroot,'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')
			svnclient = pysvn.Client()

			if channelSubscribed(channel):
				fatal("Already subscribed")
			else:

				if not os.path.isdir(localPath):
					## set up directory layout
					## but only if it isn't there
					## this can happen if subscribe fails
					try:
						os.mkdir(localPath)
						os.mkdir(localPkgs)
					except (OSError, IOError) as error:
						print 'Failed to subscribe to channel. Error was: ' + error.strerror + ' on ' + error.filename
						sys.exit(0)

					## Download package information
					svnclient.checkout(remotePath + 'packages',localPkgs)
				else:
					## Update package information
					svnclient.update(localPkgs)

				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				pkgList = []

				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to install order
				## use -pkg[0] for reverse
				pkgList = sorted(pkgList, key=lambda pkg: pkg[0])
				
				for pkgT in pkgList:
					result = initPkg(pkgT[1],rev=pkgT[2])

					## Result of pkgInit
					if result > 0:
						if result == 1:
							## Failed to init package, thus the channel subscribe has failed!
							fatal("Could not subscribe from channel. Please correct the error and try to subscribe again")
						else:
							print 'blargh'
							## Channel subscribed...but there were problems. TODO PAUSE CHANNEL?

				## What revision did we just subscribe to?
				infoList = svnclient.info2(localPkgs,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					localRevision = infoDict['rev'].number

				## Update metadata
				metadataDict['channels'][channel] = { 'name': channel, 'revision': localRevision, 'desc' : 'fake desc'}

				## Output
				verbose('Subscribed to channel ' + channel + ' - at revision ' + str(localRevision),1)

################################################################################

		elif action == 'unsubscribe':
			channel    = args[1]
			localPath  = os.path.join(scsroot,'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')
			svnclient = pysvn.Client()

			if not channelSubscribed(channel):
				fatal("Not subscribed to that channel")
			else:
				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				pkgList = []

				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to remove order
				pkgList = sorted(pkgList, key=lambda pkg: -pkg[0])
				
				for pkgT in pkgList:
					result = uninitPkg(pkgT[1])

					if result == 1:
						## Failed to remove, could not unsubscribe!
						fatal("Could not unsubscribe from channel. Please correct the error and try to unsubscribe again")
						
				## Delete data
				shutil.rmtree(localPath)

				## Update metadata
				del(metadataDict['channels'][channel])

				## Output
				verbose('Unsubscribed from channel ' + channel,1)

################################################################################

		elif action == 'check':
			## SVN
			svnclient = pysvn.Client()

			output = ''

			for channel in metadataDict['channels']:
				remotePath   = svnroot + '/c_' + channel + '/'

				## Get latest remote revision
				infoList = svnclient.info2(remotePath,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					latestRevision = infoDict['rev']

				if latestRevision.number > int(metadataDict['channels'][channel]['revision']):
					output += '{0:24}    {1:24}    {2:24}'.format(channel,str(latestRevision.number), str(metadataDict['channels'][channel]['revision']))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('CHANNEL NAME','LATEST REVISION','LOCAL REVISION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','---------------','--------------')
				print output

################################################################################

		elif action == 'update' and len(args) == 2:
			channel = args[1]
			updateChannel(channel)

		elif action == 'update-all':
			channels = os.listdir(os.path.join(scsroot,'channels'))
			for channel in channels:
				updateChannel(channel)

################################################################################

		else:
			parser.print_help()

		#### save metadata changes to disk
		## Turn "metadict" into json
		jsonOut = json.dumps(metadataDict, sort_keys=True, indent=4)

		## Write to file
		try:
			metadataFile.seek(0)
			metadataFile.truncate(0)
			metadataFile.write(jsonOut)
			metadataFile.close
		except (IOError, OSError) as error:
			fatal('Failed to write client metadata: ' + error.strerror + ' on ' + error.filename)

################################################################################

if __name__ == "__main__":
    main()

