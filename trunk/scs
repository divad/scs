#!/usr/bin/python

import os
import stat
import json
import sys
import urllib
import pysvn
import subprocess
import shutil
import pwd
import grp
import hashlib
import ConfigParser
from optparse import OptionParser, OptionGroup
import fcntl
import logging
import logging.handlers
import errno
import smtplib
from email.mime.text import MIMEText
import socket
import scslib
from scslib import inform, meta
import atexit

## Code refactoring:
# move def's to scslib? TODO (not...that...hard? :S)

## Questions:
# check is taken from /PREVIOUS/ revision...is that a good thing? TODO

#### ROADMAP (Future versions)
# Add "pkg-info" command to print package info on server
# Add "chan-info" command to print channel info on server
# Add ability for revisions to be skipped or marked as test revisions?
# Default action when local changes found should be via a pkgset thing

################################################################################
################################################################################

## "check" property
### before increment it checks all files with "check" property
#### check value can be:
#### - fail - Fail the entire package upgrade if the local file has changed - DOES NOT OVERWRITE
#### - ignore - (default) - Do nothing - don't care - OVERWITES LOCAL CHANGES
#### - warn - Warn the file has changed - OVERWRITES LOCAL CHANGES
#### - skip - don't change /that/ file, and that file alone, on the next increment - DOES NOT OVERWRITE
def checkForLocalChanges(pkg):
	global conf
	ignoreList = []
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)
	
	## Return code
	# 0 - no locally changed files
	# 1 - locally changed files, but they were all skipped
	# 2 - locally changed files, but they were all skipped or warned about
	# 3 - locally changed files, DO NOT PROCEED!
	retcode = 0

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']
			inform.debug('Checking for local changes on file: ' + dest,log=True)

			## Get SHA sums
			try:
				sourceh = shasum(source)
				desth   = shasum(dest)
			except Exception as e:
				inform.warn('Cannot check for local changes on ' + dest + ': ' + str(e))
			else:
				## Compare sums
				if not sourceh == desth:

					inform.debug('The file ' + dest + ' has been modified outside of SCS control',log=True)

					# default is warn - i.e. it overwrites
					checkAction = 'warn'

					if 'check' in properties:
						checkAction = properties['check']

					inform.debug('The file has been configured to "' + checkAction + '" in this scenario',log=True)

					if checkAction == 'fail':
						retcode = 3
						inform.error("Local changes found in package " + pkg + ", file " + dest)						
					elif checkAction == 'warn':
						retcode = 2					
						inform.warn("WARNING! Local changes found to file " + dest)
					elif checkAction == 'skip':
						retcode = 1					
						## add the file to the "ignore" list
						ignoreList.append(source)
						
	return (retcode, ignoreList)

################################################################################
################################################################################

def packageInstalled(pkg):
	if meta.data['packages'].has_key(pkg):
		return True
	else:
		return False

################################################################################
################################################################################

def channelSubscribed(channel):
	if meta.data['channels'].has_key(channel):
		return True
	else:
		return False

################################################################################
################################################################################

def listFiles(pkg):
	global conf
	svnclient = pysvn.Client()
	propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)

	for propSet in propList:
		source     = propSet[0]
		properties = propSet[1]

		if 'dest' in properties:
			dest = properties['dest']
			print '{0:38}  {1:38}'.format(dest, source)

################################################################################
################################################################################

def printPackageHeader():
	print '{0:14}  {1:14}  {2:9}  {3:37}'.format('PACKAGE NAME','REVISION','STATUS','DESCRIPTION')
	print '{0:14}  {1:14}  {2:9}  {3:37}'.format('------------','--------','------','-----------')

################################################################################
################################################################################

def printPackageInfo(pkg):
	data = meta.data['packages'][pkg]
	if type(data).__name__=='dict':
		if isPackageSuspended(data['name']):
			flags = 'SUSPENDED'
		else:
			flags = 'OK'

		if data.has_key('name') and data.has_key('revision') and data.has_key('desc'):
			print "{0:14}  {1:14}  {2:9}  {3:37}".format(str(data['name']), str(data['revision']), flags, str(data['desc']))
		elif data.has_key('name') and data.has_key('revision'):
			print "{0:14}  {1:14}  {2:9}  {3:37}".format(str(data['name']), str(data['revision']), flags,'N/A')
		else:
			inform.fatal('Unable to understand data: ' + str(e))
	else:
		inform.fatal('Unable to understand data: ' + str(e))

################################################################################
################################################################################

def suspendPackage(pkg,reason):
	if packageInstalled(pkg):
		meta.data['packages'][pkg]['status'] = 'suspended'
		meta.data['packages'][pkg]['suspend_reason'] = reason

def resumePackage(pkg):
	if isPackageSuspended(pkg):
		del(meta.data['packages'][pkg]['status'])
		del(meta.data['packages'][pkg]['suspend_reason'])

def isPackageSuspended(pkg):
	if packageInstalled(pkg):
		if meta.data['packages'][pkg].has_key('status'):
			if meta.data['packages'][pkg]['status'] == 'suspended':
				return True

	return False

################################################################################
################################################################################

def shasum(filePath,blocksize=2**20):
	sha = hashlib.sha256()
	f = open(filePath,'rb')
	while True:
		data = f.read(blocksize)
		if not data:
			break;
		sha.update(data)
	return sha.hexdigest()

################################################################################
################################################################################

## Runs a package script, returns false 
def runScript(pkgName,scriptName):
	global conf
	inform.debug('Executing ' + scriptName,log=True)
	scriptPath = os.path.join(conf['scsroot'],'packages',pkgName,'scripts',scriptName)

	## CHMOD First
	os.chmod(scriptPath,stat.S_IRWXU)

	if os.path.getsize(scriptPath) == 0:
		inform.debug("Script is empty; not executing",log=True)
		return False

	## Now run the script
	try:
		script = subprocess.Popen([scriptPath],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		(stdoutdata, stderrdata) = script.communicate()
		
		## If the command returned a non-zero exit we should log its full output to error()
		if not script.returncode == 0:
			inform.error(stdoutdata)
		
		## Log the error
		inform.error(scriptName + ' script returned non-zero')
		
		## Return true to say we found an error
		return True
		
	except OSError as e:
		inform.error('Execution of script ' + scriptName + ' failed: ' + str(e))
		## Return true to say we found an error
		return True
		
	## Return no errors (False = no errors!
	return False

################################################################################
################################################################################

def fetchMetadata(metadataUrl):
	inform.debug('Fetching metadata from server')
	try:
		f = urllib.urlopen(metadataUrl)
		jsonData = f.read()
		f.close()
	except IOError as e:
		inform.fatal('Unable to download ' + metadataUrl + ': ' + str(e.strerror))

	try:
		metadict = json.loads(jsonData)
	except (TypeError,ValueError) as e:
		inform.fatal('Unable to understand server metadata: ' + str(e))

	return metadict

################################################################################
################################################################################

# 0 = success
# 1 = false
def uninitPkg(pkg):
	global conf

	if packageInstalled(pkg):
		errorOccured = runScript(pkg,'uninit')
		
		if errorOccured:
			return 1
		else:
			## Delete data
			shutil.rmtree(os.path.join(conf['scsroot'],'packages',pkg))

			## Update metadata
			del(meta.data['packages'][pkg])

			## Output
			inform.info('Removed package "' + pkg + '"')
	
			## Return OK
			return 0
	else:
		inform.info('Package "' + pkg + '" not installed so not removing',log=True)
		return 0

################################################################################
################################################################################

def isChannelUpToDate(channel):
	global conf
	svnclient = pysvn.Client()
	
	remotePath  = conf['svnroot'] + '/' + channel + '/'

	## Get the latest revision of the channel
	infoList = svnclient.info2(remotePath,recurse=False)
	for infoTuple in infoList:
		infoDict = infoTuple[1]
		latestRevision = infoDict['rev']
	inform.debug('Latest remote channel revision is ' + str(latestRevision.number))

	## Get the installed revision
	localRevision = int(meta.data['channels'][channel]['revision'])
	inform.debug('Latest local channel revision is ' + str(localRevision))
	
	if localRevision == latestRevision.number:
		return 1
	else:
		return 0
		
################################################################################
################################################################################		
		
def updateChildChannels(channel):
	# List all channels
	for name in meta.data['channels']:
	
		# If its a child channel
		if meta.data['channels'][name].has_key('parent'):
		
			# And its parent is the channel we care about
			if meta.data['channels'][name]['parent'] == channel:

				# Then update it
				updateChannel(name)
				
################################################################################
################################################################################				

# results
# 0 OK!
# 1 Could not upgrade
def updateChannel(channel):
	inform.debug('updateChannel(' + channel + ') called')
	global conf
	svnclient = pysvn.Client()

	if channelSubscribed(channel):
		remotePath  = conf['svnroot'] + channel + '/'
		localPath   = os.path.join(conf['scsroot'],'channels',channel)
		localPkgs   = os.path.join(localPath,'packages')
		upgradeFile = remotePath + 'upgrade'

		## Get the latest revision of the channel
		infoList = svnclient.info2(remotePath,recurse=False)
		for infoTuple in infoList:
			infoDict = infoTuple[1]
			latestRevision = infoDict['rev']
		inform.debug('Latest remote channel revision is ' + str(latestRevision.number))

		## Get the installed revision
		localRevision = int(meta.data['channels'][channel]['revision'])
		inform.debug('Latest local channel revision is ' + str(localRevision))

		## Decide upon which revision to go to????
		if localRevision == latestRevision.number:
			## Mark the channel as up to date
			inform.info('Channel "' + channel + '" is up to date')

			## Update child channels
			updateChildChannels(channel)
			return 0
		else:
			inform.info('Updating channel "' + channel + '" to revision ' + str(localRevision +1))
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, localRevision + 1)

		## No need to download the upgrade file, we'll just read its properties from remote :)
		## Get the properties
		propList = svnclient.proplist(upgradeFile,revision=revisionToUse)

		for propSet in propList:
			properties = propSet[1]

			if properties.has_key('name') and properties.has_key('revision') and properties.has_key('action'):
				if properties['action'] == 'install':
					## Install 'revision' of 'name'
					(retCode,faultMsg) = initPkg(properties['name'],int(properties['revision']))
					
					if retCode > 0:
						inform.error("Could not init/upgrade " + properties['name'] + ". Channel could not be updated")

						## Alert email
						if not conf['mailaddr'] == None:
							text  = "An error occured whilst trying to update the channel '" + channel + "'\n"
							text += "The error occured within the package '" + properties['name'] + "'\n"
							text += "Reason: " + faultMsg
							
							hostname = socket.gethostname()
							
							msg = MIMEText(text)
							msg['Subject'] = "scs on " + hostname + " failed to update channel '" + channel + "'"
							msg['From'] = 'root@' + hostname
							msg['To'] = conf['mailaddr']
					
							smtp = smtplib.SMTP(conf['smtp'])
							smtp.sendmail('root@null', conf['mailaddr'], msg.as_string())
							smtp.quit()
					
						## Return 1 to say we failed
						return 1

			elif properties.has_key('name') and properties.has_key('action'):
				if properties['action'] == 'remove':
					## Remove 
					result = uninitPkg(properties['name'])

					if result == 1:
						inform.fatal("Could not upgrade channel. Please correct the error and try to upgrade again")
						return 1
					
			else:
				inform.warn('Warning! Channel upgrade file does not have properties set against it!')

		## Update package info (Although we don't actually use the info until an unsubscribe - but they are there if an admin wants them)
		svnclient.update(localPkgs,revision=revisionToUse)

		## Save new revision
		meta.data['channels'][channel]['revision'] = revisionToUse.number;

		## We're upgraded
		if revisionToUse.number < latestRevision:
		
			## We need to recursive-call and upgrade again! :)
			updateChannel(channel)
			
		else:		
			## Update child channels
			updateChildChannels(channel)

	else:
		inform.fatal('Not subscribed to channel ' + channel,log=False)
		
################################################################################
################################################################################		
		
def installPackageData(localDataPath,ignoreList=[]):
	svnclient = pysvn.Client()

	## Did a fault occur during property application?
	faultOccured = False

	## Get properties
	fileList = svnclient.proplist(localDataPath,recurse=True)

	## For each file...
	for propSet in fileList:
		source     = propSet[0]
		properties = propSet[1]

		## Skip files we've been instructed to due to local changes
		if source in ignoreList:
			inform.debug('Skipping file ' + source + ' from inst stage due to local changes')
			continue;

		## By default, apply properties to the source file in /opt/scs/packages/<pkg/data/
		dest = source

		## If there is a 'dest' property
		if 'dest' in properties:
			dest = properties['dest']
			
			## Default action is copy
			action = 'copy'

			## Load a user-defined action
			if 'action' in properties:
				action = properties['action']

			## Deal with immutability
			if not os.path.islink(dest):
				if isFileImmutable(dest):
					chattr = subprocess.Popen(['chattr', '-i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
					(stdoutdata, stderrdata) = chattr.communicate()
					retcode = chattr.returncode

					if retcode > 0:
						inform.debug('Unable to remove immutable flag from ' + dest)

			if action == 'copy':
				try:
					shutil.copyfile(source,dest)
				except IOError as e:
					inform.error("Unable to copy from " + source + " to " + dest + ": " + str(e))
					faultOccured = True

			elif action == 'link':
				try:
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					inform.error("Unable to link " + source + " to " + dest + ": " + str(e))
					faultOccured = True

			elif action == 'linkr':
				try:
					if os.path.isdir(dest):
						shutil.rmtree(dest)
					elif os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					inform.error("Unable to linkr " + source + " to " + dest + ": " + str(e))
					faultOccured = True

			elif action == 'linko':
				try:
					if os.path.isfile(dest):
						os.unlink(dest)
					os.symlink(source,dest)
				except (IOError, OSError) as e:
					inform.error("Unable to linko " + source + " to " + dest + ": " + str(e))
					faultOccured = True

		## chmod - set the permissions to octal mode
		if 'chmod' in properties:
			try:
				os.chmod(dest,int(properties['chmod'],8))
			except Exception as e:
				inform.error('Could not apply chmod property to ' + dest + ': ' + str(e))	
				faultOccured = True

		## owner - set the owner to
		if 'owner' in properties:
			try:
				pwd = pwd.getpwnam(properties['owner'])
				uid = pwd[2]
				os.chown(dest,uid)
			except Exception as e:
				inform.error('Could not apply owner property to ' + dest + ': ' + str(e))
				faultOccured = True

		## group - set the group to
		if 'group' in properties:
			try:
				grp = grp.getgrnam(properties['group'])
				gid = grp[2]
				os.chown(dest,-1,gid)
			except Exception as e:
				inform.error('Could not apply group property to ' + dest + ': ' + str(e))
				faultOccured = True

		if 'uid' in properties:
			try:
				os.chown(dest,properties['uid'],-1)
			except Exception as e:
				inform.error('Could not apply uid property to ' + dest + ': ' + str(e))
				faultOccured = True

		## group - set the group to
		if 'gid' in properties:
			try:
				os.chown(dest,-1,properties['gid'])
			except Exception as e:
				inform.error('Could not apply gid property to ' + dest + ': ' + str(e))
				faultOccured = True

		## immutable - set the file to immutable after
		if 'immutable' in properties:
			## NOTE although python has os.chflags, due to a python configure bug they
			## are NEVER compiled in - stupid python.

			if not os.path.islink(dest):
				chattr = subprocess.Popen(['chattr', '+i', dest],stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
				(stdoutdata, stderrdata) = chattr.communicate()
				retcode = chattr.returncode

				if retcode > 0:
					inform.error(stdoutdata)
					faultOccured = True
					
			else:
				inform.warn('Not applying immutable attribute to symlink - not possible')
				
				
	return faultOccured

################################################################################
################################################################################

# Returns 0 if it was init'ed
# Returns 1 if it wasn't
# Returns 2 if it was, but failures occured and the package is now suspended
# Returns a string or None, if 1/2 its a string saying why, useful for logging or whatever

def initPkg(pkg,rev=-1):
	global conf
	global options
	global args

	## Get package info from server
	metadict = fetchMetadata(conf['metaurl'])

	## See if the package requested actually exists
	found = False
	for pkgName in metadict['packages']:
		if pkgName == pkg:
			found = True

	## Catch errors
	if not found:
		inform.error('Could not find package to install in server metadata')
		return (1,'Could not find package to install in server metadata')

	if metadict['packages'][pkg].has_key('desc'):
		packageDescription = metadict['packages'][pkg]['desc']
	else:
		packageDescription = ''

	## SVN
	svnclient = pysvn.Client()

	## Work out paths
	remotePath   = conf['svnroot'] + pkg + '/' 
	localPath    = os.path.join(conf['scsroot'],'packages',pkg)
	localScripts = os.path.join(localPath,'scripts')
	localData    = os.path.join(localPath,'data')
	
	## Get latest remote revision
	infoList = svnclient.info2(remotePath,recurse=False)
	for infoTuple in infoList:
		infoDict = infoTuple[1]
		latestRevision = infoDict['rev']

	## Should we use a speciifc max version? (for channels tagged at a specific version)
	if rev >= 0 and rev <= latestRevision.number:
		latestRevision = pysvn.Revision(pysvn.opt_revision_kind.number, rev)

	## What type, init or upgrade?
	upgrade = False

	## A list of files to ignore during property-apply phase
	ignoreList = []

	## If this is an upgrade
	if packageInstalled(pkg):
		upgrade = True

		## Get local revision installed
		localRevision = int(meta.data['packages'][pkg]['revision'])

		if localRevision == latestRevision.number:
			inform.info('Package ' + pkg + ' up to date (revision ' + str(localRevision) + ')')
			return (0,None)
		else:
			revisionToUse = pysvn.Revision(pysvn.opt_revision_kind.number, int(localRevision) + 1)

		inform.info('Updating package "' + pkg + '" to revision ' + str(revisionToUse.number),log=True)
			
		## Is the package suspended?
		if isPackageSuspended(pkg):
			inform.error("Package '" + pkg + "' is currently suspended: " + meta.data['packages'][pkg]['suspend_reason'])
			return (1,"Package '" + pkg + "' is currently suspended: " + meta.data['packages'][pkg]['suspend_reason'])

		## Should we ignore local changes?
		ignore = options.ignore

		## If we shouldn't then check for local changes
		if not ignore:
			inform.info('Checking for local changes',log=True)
			(localChangesResult,ignoreList) = checkForLocalChanges(pkg)
			
		## If local changes were detected and we must not proceed because of them...
		if localChangesResult == 3:
			inform.error('One or more files have been changed locally, this must be corrected before upgrading')
			return (1,'One or more files have been changed locally, this must be corrected before upgrading')

		## Pre-increment ("pre-upgrade") script
		if runScript(pkg,'preinc'):
			inform.error('Could not init package')
			return (1,'The preinc script returned an error')

		## Update data now
		inform.debug('Updating package data')
		svnclient.update(localData,revision=revisionToUse)
		
	else:
		revisionToUse = latestRevision
		inform.info('Installing ' + pkg,log=True)

		## Create paths only if they haven't been already
		## This can happen if a pre* script failed
		if not os.path.isdir(localPath):
			## set up directory layout
			try:
				os.mkdir(localPath)
				os.mkdir(os.path.join(localPath,'conf'))
				os.mkdir(os.path.join(localPath,'scripts'))
				os.mkdir(os.path.join(localPath,'data'))
			except (OSError, IOError) as e:
				print 'Failed to init package. Error was: ' + e.strerror + ' on ' + e.filename
				sys.exit(0)

			## Initial check out of data
			inform.debug('Deploying package data')
			svnclient.checkout(remotePath + 'data',localData,revision=revisionToUse)

		else:
			inform.debug('Updating package data')
			svnclient.update(localData,revision=revisionToUse)

	inform.debug('Deploying scripts')
	svnclient.export(remotePath + 'scripts',localScripts,revision=revisionToUse,force=True,recurse=True)

	## Run scripts
	if upgrade:
		if runScript(pkg,'preup'):
			inform.error('Cancelling package init 1')
			return (1,'The preup script returned an error')			
	else:
		if runScript(pkg,'preinit'):
			inform.error('Cancelling package init 2')
			return (1,'The preinit script returned an error')

	if runScript(pkg,'preinst'):
		inform.error('Cancelling package init 3')
		return (1,'The preinst script returned an error')

	## If anything fails now then we can't/shouldn't stop, but we should mark
	## a failure and then optionally the calling function can suspend the pkg
	## and channel
	faultMsg  = ''

	## Install the package data
	faultOccured = installPackageData(localData,ignoreList=ignoreList)
	
	if faultOccured:
		faultMsg = 'A fault occured during applying package data properties'
	
	if runScript(pkg,'postinst'):
		faultMsg = 'The postinst script returned an error'
		faultOccured = True

	if upgrade:
		if runScript(pkg,'postup'):
			faultMsg = 'The postup script returned an error'
			faultOccured = True
	else:
		if runScript(pkg,'postinit'):
			faultMsg = 'The postinit script returned an error'
			faultOccured = True

	## Output some info
	inform.info('Package ' + pkg + ' now at revision ' + str(revisionToUse.number),log=True)

	## update metadata
	meta.data['packages'][pkg] = { 'name': pkg, 'revision': revisionToUse.number, 'desc': packageDescription}

	if faultOccured:
		suspendPackage(pkg,faultMsg)
		inform.error('An error occured during the init process. The package "' + pkg + '" is now suspended')
		return 2
	else:
		## Recursive call package if we're not at the latest now
		if revisionToUse.number < latestRevision.number:
			return initPkg(pkg)	
		else:
			inform.info('Package ' + pkg + ' is now up to date',log=True)
			return 0

################################################################################
################################################################################

def main():
	## Load SVN client
	svnclient = pysvn.Client()

	#### Define the usage text
	usage = '''Usage: %prog [options] ACTION [...]

    Update functions:

        check                      List available updates from channels
        update        CHANNEL      Apply updates from a channel
        update-all                 Apply all updates from all channels

    Basic package functions:

        installed                  List installed packages
        packages                   List all available packages
        status        PACKAGE      Show the package status          

    Package maintenance functions: 

        verify        PACKAGE      Verify system conforms to package spec
        verify-all                 Verify system conforms to all package specs
        files         PACKAGE      List files which are part of PACKAGE
        files-all                  List files from all packages
        force         PACKAGE      Force-apply package data to system, ignoring
                                   any local changes that might occur.
        force-all                  As above, but for all installed packages
        owner         FILEPATH     Determine if FILEPATH is owned by a package
        suspend       CHANNEL      Lock a package so it cannot be updated
        resume        CHANNEL      Unlock a package

    Channel-related actions:
        subscribed                 List channels this system is subscribed to
        channels                   List all available channels 
        subscribe     CHANNEL      Subscribe to a channel
        unsubscribe   CHANNEL      Unsubscribe from a channel
        
    Advanced package functions:
    
        init          PACKAGE      Install/upgrade package (Not recommended)
        uninit        PACKAGE      Remove package (Not recommended)'''

	## Log variable
	global logOpened
	logOpened = False

	## Set a 'good' working directory
	os.chdir('/tmp')

	#### Parse command line options
	parser = OptionParser(usage=usage,version='%prog version 3')
	parser.add_option('-c','--config-file',dest='config',default="/etc/scs.conf",help='Set the configuration file to use')
	parser.add_option('-f','--force',dest='ignore',default=False,action="store_true",help='Ignore local changes and proceed anyway')
	parser.add_option('-d','--debug',dest='debug',default=False,action="store_true",help='Print debug messages during execution')
	parser.add_option('-q','--quiet',dest='quiet',default=False,action="store_true",help='Print no output except in the case of error')
	group = OptionGroup(parser,"Options for 'init'")
	group.add_option('-r','--revision',type="int",default=-1,dest='revision',help='Specify a specific revision of the package to tag')
	parser.add_option_group(group)

	global options
	global args
	(options, args) = parser.parse_args()
	
	#### Set debug/quiet
	if options.debug:
		inform.setDebug()
	if options.quiet:
		inform.setQuiet()

	#### LOAD CONFIG
	config = ConfigParser.RawConfigParser()
	config.read(options.config)

	global conf
	conf = {}
	conf['scsroot']  = '/opt/scs/'
	conf['svnroot']  = ''
	conf['metaurl']  = ''
	conf['smtp']     = 'rcfg.soton.ac.uk'
	#conf['mailaddr'] = None
	conf['mailaddr'] = 'notify@scs.soton.ac.uk'
	
	## log file
	if config.has_option('client','log file'):
		inform.openLog(config.get('client','log file'))
	else:
		inform.openLog('/var/log/scs.log')
	
	## scs root
	if config.has_option('client','scs root'):
		configValue = config.get('client','scs root')
		if os.path.isdir(configValue):
			conf['scsroot'] = configValue
		else:
			inform.fatal('The scs root specified in ' + options.config + ' is not a directory')

	## svn root
	if config.has_option('client','svn root'):
		conf['svnroot'] = config.get('client','svn root')
	else:
		inform.fatal('No svn root defined in ' + options.config)

	if config.has_option('client','metadata url'):
		conf['metaurl'] = config.get('client','metadata url')
	else:
		inform.fatal('No metadata url defined in ' + options.config)
		
	## email options
	if config.has_option('client','smtp server'):
		configValue = config.get('client','smtp server')
		conf['smtp'] = configValue
	if config.has_option('client','notify email'):
		configValue = config.get('client','notify email')
		conf['mailaddr'] = configValue		

	## Load metadata
	meta.load(os.path.join(conf['scsroot'],'client.meta'))
	
	## Register a close handler so it is saved at exit
	atexit.register(meta.save)
	
	#### SWTICH ACTIONS
	if len(args) < 1:
		parser.print_help()
	else:
		action = args[0]

################################################################################

		if action == 'installed':
			output = ''
			looped = False
			for pkg in meta.data['packages']:

				if not looped:
					printPackageHeader()
					looped = True

				printPackageInfo(pkg)

################################################################################

		elif action == 'packages':
			metadict = fetchMetadata(conf['metaurl'])
			output = ''
			for pkgName in metadict['packages']:
				data = metadict['packages'][pkgName]
				if type(data).__name__=='dict':
				
					## Get the latest channel revision
					remotePath  = conf['svnroot'] + '/' + pkgName + '/'

					## Get the latest revision of the package
					infoList = svnclient.info2(remotePath,recurse=False)
					for infoTuple in infoList:
						infoDict = infoTuple[1]
						latestRevision = infoDict['rev']
						
					if data.has_key('name') and data.has_key('desc'):
						output += "{0:14}  {1:8}  {2:44}\n".format(str(data['name']), str(latestRevision.number), str(data['desc']))
					elif data.has_key('name'):
						output += "{0:14}  {1:8}  {2:44}\n".format(str(data['name']), str(latestRevision.number), 'N/A')
					else:
						inform.fatal('Unable to understand data: ' + str(e))
				else:
					inform.fatal('Unable to understand data: ' + str(e))

			if len(output) > 0:
				print '{0:14}  {1:8}  {2:44}'.format('PACKAGE NAME','REVISION','DESCRIPTION')
				print '{0:14}  {1:8}  {2:44}'.format('------------','--------','-----------')
				sys.stdout.write(output)

################################################################################

		elif action == 'status' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				data = meta.data['packages'][pkg]

				print '           Name: ' + data['name']
				print ' Local Revision: ' + str(data['revision'])

				if data.has_key('desc'):		
					print '    Description: ' + data['desc']

				if isPackageSuspended(pkg):
					print '         Status: SUSPENDED'
					if data.has_key('suspend_reason'):
						print '        Reason: ' + data['suspend_reason']
				else:
					print '         Status: OK'
			else:
				inform.fatal('Package not installed',log=False)
				
################################################################################				

		elif action == 'suspend' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			if packageInstalled(pkg):
				if isPackageSuspended(pkg):
					inform.fatal('Package is already suspended',log=False)
				else:
					suspendPackage(pkg,'Suspended by system administrator')
			else:
				inform.fatal('Package not installed',log=False)
				
################################################################################				

		elif action == 'resume' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				if isPackageSuspended(pkg):
					resumePackage(pkg)
				else:
					inform.fatal('Package is not suspended',log=False)
			else:
				inform.fatal('Package not installed',log=False)
				
################################################################################				

		elif action == 'verify' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				checkForLocalChanges(pkg)
			else:
				inform.fatal('Package not installed',log=False)
				
################################################################################

		elif action == 'verify-all':
			for pkg in meta.data['packages']:
				inform.debug('Checking for local changes to pkg "' + pkg + '"',log=True)
				checkForLocalChanges(pkg)
				
################################################################################				

		elif action == 'force' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')
				installPackageData(dataPath)
			else:
				inform.fatal('Package not installed',log=False)
				
################################################################################

		elif action == 'force-all':
			for pkg in meta.data['packages']:
				inform.debug('Forcing package data processing on "' + pkg + '"',log=True)
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')			
				installPackageData(dataPath)		

################################################################################

		elif action == 'files' and len(args) == 2:
			pkg = args[1]

			if packageInstalled(pkg):
				dataPath = os.path.join(conf['scsroot'],'packages',pkg,'data')
				listFiles(pkg)
			else:
				inform.fatal('No such package')

################################################################################

		elif action == 'files-all':
			for pkg in meta.data['packages']:
				inform.info(pkg + ':')
				listFiles(pkg)

################################################################################

		elif action == 'owner' and len(args) == 2:
			fileName = args[1]
			for pkg in meta.data['packages']:
				propList = svnclient.proplist(os.path.join(conf['scsroot'],'packages',pkg,'data'),recurse=True)

				for propSet in propList:
					source     = propSet[0]
					properties = propSet[1]

					if 'dest' in properties:
						dest = properties['dest']

						if dest == fileName:
							print pkg

#################################################################################

		elif action == 'init' and len(args) == 2:
			## Store package name in a friendly variable
			pkg = args[1]

			## Get metadata from server
			metadict = fetchMetadata(conf['metaurl'])

			## See if the package requested actually exists
			found = False
			for pkgName in metadict['packages']:
				if pkgName == pkg:
					found = True

			## Catch errors
			if not found:
				inform.fatal('No such package on server')

			initPkg(pkg)

################################################################################

		elif action == 'uninit' and len(args) == 2:
			pkg = args[1]
			if packageInstalled(pkg):
				uninitPkg(pkg)

################################################################################

		elif action == 'channels':
			metadict = fetchMetadata(conf['metaurl'])
			scslib.listChannels(metadict)
			
################################################################################

		elif action == 'subscribed':
			scslib.listChannels(meta.data)

################################################################################

		elif action == 'subscribe' and len(args) == 2:
			channel    = args[1]
			remotePath = conf['svnroot'] + '/' + channel + '/'
			localPath  = os.path.join(conf['scsroot'],'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')

			## Get package info from server
			remoteMeta = fetchMetadata(conf['metaurl'])

			## See if the channel requested actually exists
			found = False
			for channelName in remoteMeta['channels']:
				if channelName == channel:
					found = True

			## Catch errors
			if not found:
				inform.fatal('No such channel exists on the server')

			if remoteMeta['channels'][channel].has_key('desc'):
				channelDescription = remoteMeta['channels'][channel]['desc']
			else:
				channelDescription = ''

			if channelSubscribed(channel):
				inform.info("Already subscribed to channel")
			else:

				## If this a child channel
				if remoteMeta['channels'][channel].has_key('parent'):
					## Make sure we've installed the parent...
					if not channelSubscribed(remoteMeta['channels'][channel]['parent']):
						inform.fatal('To subscribe to a child channel you must first subscribe to its parent')
					else:
						## Make sure the parent is up to date first... (the key component of a "child" channel)
						if not isChannelUpToDate(remoteMeta['channels'][channel]['parent']):
							inform.fatal('The parent channel is not up to date. You must update it first')

				if not os.path.isdir(localPath):
					## set up directory layout
					## but only if it isn't there
					## this can happen if subscribe fails
					try:
						os.mkdir(localPath)
						os.mkdir(localPkgs)
					except (OSError, IOError) as error:
						print 'Failed to subscribe to channel. Error was: ' + error.strerror + ' on ' + error.filename
						sys.exit(0)

					## Download package information
					svnclient.checkout(remotePath + 'packages',localPkgs)
				else:
					## Update package information
					svnclient.update(localPkgs)

				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				pkgList = []
				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to install order
				## use -pkg[0] for reverse
				pkgList = sorted(pkgList, key=lambda pkg: pkg[0])
				
				## Install packages
				for pkgT in pkgList:
				
					## Install it and get a result
					(retcode,faultMsg) = initPkg(pkgT[1],rev=pkgT[2])

					## Result of pkgInit
					if retcode > 0:
						inform.fatal("Could not init/upgrade " + properties['name'] + ". Could not subscribe to channel.")

				## What revision did we just subscribe to?
				infoList = svnclient.info2(localPkgs,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					localRevision = infoDict['rev'].number

				## Update metadata with the new channel
				meta.data['channels'][channel] = { 'name': channel, 'revision': localRevision, 'desc' : channelDescription}
				
				## Update metadata
				if remoteMeta['channels'][channel].has_key('parent'):
					meta.data['channels'][channel]['parent'] = remoteMeta['channels'][channel]['parent']

				## Output
				inform.info('Subscribed to channel ' + channel + ' - at revision ' + str(localRevision),log=True)

################################################################################

		elif action == 'unsubscribe':
			channel    = args[1]
			localPath  = os.path.join(conf['scsroot'],'channels',channel)
			localPkgs  = os.path.join(localPath,'packages')

			if not channelSubscribed(channel):
				inform.fatal("Not subscribed to that channel",log=False)
			else:
				## Does this channel have children? If so...GO AWAY...
			
				## Now do a property walk to know what packages to install
				propList = svnclient.proplist(localPkgs,recurse=True)

				pkgList = []

				for propSet in propList:
					fname      = propSet[0]
					properties = propSet[1]

					if 'revision' in properties and 'name' in properties:
						if 'order' in properties:
							pkgList.append((int(properties['order']),properties['name'],int(properties['revision'])))
						else:
							pkgList.append((999999999,properties['name'],properties['revision']))

				## Sort according to remove order
				pkgList = sorted(pkgList, key=lambda pkg: -pkg[0])
				
				for pkgT in pkgList:
					result = uninitPkg(pkgT[1])

					if result == 1:
						## Failed to remove, could not unsubscribe!
						inform.fatal("Could not unsubscribe from channel. Please correct the error and try to unsubscribe again")
						
				## Delete data
				shutil.rmtree(localPath)

				## Update metadata
				del(meta.data['channels'][channel])

				## Output
				inform.info('Unsubscribed from channel ' + channel,log=True)

################################################################################

		elif action == 'check':
			output = ''

			for channel in meta.data['channels']:
				remotePath   = conf['svnroot'] + '/' + channel + '/'

				## Get latest remote revision
				infoList = svnclient.info2(remotePath,recurse=False)
				for infoTuple in infoList:
					infoDict = infoTuple[1]
					latestRevision = infoDict['rev']

				if latestRevision.number > int(meta.data['channels'][channel]['revision']):
					output += '{0:24}    {1:24}    {2:24}'.format(channel,str(latestRevision.number), str(meta.data['channels'][channel]['revision']))

			if len(output) > 0:
				print '{0:24}    {1:24}    {2:24}'.format('CHANNEL NAME','LATEST REVISION','LOCAL REVISION')
				print '{0:24}    {1:24}    {2:24}'.format('------------','---------------','--------------')
				print output

################################################################################

		elif action == 'update' and len(args) == 2:
			channel = args[1]
			updateChannel(channel)

		elif action == 'update-all':
			for channel in meta.data['channels']:
				## Only update top-level parent channels, updateChannel() takes care of child channels
				if not meta.data['channels'][channel].has_key('parent'):
					updateChannel(channel)

################################################################################

		else:
			parser.print_help()

################################################################################

if __name__ == "__main__":
    main()

